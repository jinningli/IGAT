<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Demo - Learning to Slice</title>
<!--  <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" type="image/x-icon">-->
  <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/examples/js/geometries/TextGeometry.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/examples/js/loaders/FontLoader.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f5f5f5;
    }
    .container {
      margin-top: 20px;
      text-align: center;
    }
    button {
      margin: 10px;
      padding: 10px 20px;
      font-size: 16px;
    }
    .input-group {
      display: flex;
      margin-top: 0px;
      justify-content: flex-start;
      align-items: center;
    }
    .input-group input {
      margin: 0 5px;
      padding: 5px;
    }
    #CanvasB1, #CanvasB2, #CanvasB3, #CanvasB4, #CanvasP1, #CanvasP2, #CanvasP3, #CanvasP4, #CanvasP5, #CanvasP6, #CanvasP7, #CanvasP8 {
      width: 300px;
      height: 180px;
      border: 1px solid black;
      margin-top: 20px;
    }
    #tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 5px;
      border-radius: 5px;
      pointer-events: none;
      display: none;
    }
    #logTextBox {
        width: 900px;
        height: 90px;
        border: 1px solid #ccc;
        overflow-y: scroll;
        margin-top: 10px;
        padding: 5px;
        white-space: pre-wrap;
        word-wrap: break-word;

        /* Added styles */
        font-family: 'Courier New', Courier, 'Lucida Sans Typewriter', 'Lucida Console', monospace;
        font-size: 10px; /* Smaller font size */
        text-align: left; /* Horizontal left alignment */
        display: flex;
        align-items: center; /* Vertical centering */
    }
table {
    border-collapse: collapse;
    width: 1000px;  /* Enforce the width of the table */
}

table, th, td {
    border: 1px solid black;
}

tr th:first-child {
    width: 15%;  /* Set width for the first column */
}

th, td {
    padding: 10px;
    text-align: center;
    font-size: 12px;  /* Set a smaller font size for the entire table */
}

/* Bold the first column for each row */
tr td:first-child {
    font-weight: bold;
}

/* Third row specific styling */
tr:nth-child(3) td {
    text-align: left;  /* Align text to the left */
    vertical-align: top;  /* Align text to the top */
}
  </style>
</head>
<body>
  <div class="container">
    <div style="display: flex; justify-content: center; align-items: center;">
        <div style="display: flex;">
            <!-- Left div with some vertical space below the image -->
<!--            <div style="margin-right: 25px;">-->
<!--                <img src="{{ url_for('static', filename='images/logo.png') }}" height="30px" alt="img">-->
<!--            </div>-->
            <!-- Right div -->
<!--            <div>-->
<!--                <img src="{{ url_for('static', filename='images/logo2.png') }}" height="50px" alt="img">-->
<!--            </div>-->
        </div>
    </div>
    <h2>Paper Demo - Learning to Slice: Self-Supervised<br>Interpretable Hierarchical Representation Learning with Graph Auto-Encoder Tree</h2>

      <div style="display: flex; justify-content: center; margin-top: 15px;">
    <div style="max-width: 1200px; text-align: left; border: 1px solid #ccc; padding: 15px; background-color: #fff; box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);">
        <!-- Instructions Header and Introduction (always visible) -->
        <h3 style="margin-top: 0;">Instructions</h3>

        <p style="font-size: 14px;">
            <strong>Introduction:</strong> This 2-layer IGAT model demo automatically and jointly solve two key tasks:<br>
            1) Detecting the the most representative political subjects and slice the dataset accordingly, and<br>
            2) Detecting belief polarization for each subject, identifying the positions of users and tweets.<br>
            The model learns an interpretable hierarchical representation (IHR): the first level represents political subjects (shown in the subject embedding below),
            and the second level represents polarization beliefs (shown in the belief embedding below).
        </p>

        <p style="font-size: 14px;">
            <strong>Instructions:</strong> The model supports both unsupervised and semi-supervised modes:
        </p>
        ...

        <!-- Collapsible content (initially hidden) -->
        <div id="instructionsContent" style="display: none;">
            <p style="font-size: 14px;"><strong>(1) Unsupervised Mode:</strong> Fully automated. Follow these steps to use it:</p>
            <ul style="font-size: 14px; margin-left: 20px;">
                <li>(i) Click <strong>[Pre-Training]</strong> to pre-train the first-level subject embeddings. (You can modify the number of iterations using the text box. Click again to run additional iterations.)</li>
                <li>(ii) Click <strong>[Joint Training]</strong> to jointly train subject and belief embeddings. (You can modify the number of iterations using the text box. Click again to run additional iterations.)</li>
                <li>(iii) Monitor the training process through the 3-D plots (Circles: Users; Triangles: Tweets), as well as the tables below showing the detected political subjects, beliefs, and representative tweets for each belief.</li>
            </ul>

            <p style="font-size: 14px;"><strong>(2) Semi-Supervised Mode:</strong> Allows you to annotate partial data for customization and enhanced performance. This can be done interactively (manual annotation) or automatically with GPT. Follow these steps:</p>
            <ul style="font-size: 14px; margin-left: 20px;">
                <li>(i) Click <strong>[Pre-Training]</strong> to pre-train the first-level subject embeddings.</li>
                <li>(ii) (Option 1): <strong>[Add Manual Annotation]:</strong> Hover over points to view tweets (triangles), click to select a tweet, then type in the political subject and belief (e.g., political subject=EDCA, belief=Pro). Click <strong>[Add Manual Annotation]</strong> to submit. Annotated tweets will appear in purple and increase in size.</li>
                <li>(ii) (Option 2): <strong>[Add GPT Annotation]:</strong> To automate annotations, enter the percentage of tweets to annotate and click <strong>[Add GPT Annotation]</strong>.</li>
                <li>(iii) You may optionally click again <strong>[Pre-Training]</strong> to pre-train the first-level subject embeddings.</li>
                <li>(iv) Click <strong>[Joint Training]</strong> to jointly train subject and belief embeddings.</li>
                <li>Note that users can perform the two annotation options (step 2) at any point during training, even before, after, or between steps 3 and 4.</li>
                <li>(v) Monitor the training process and results.
            </ul>

            <p style="font-size: 14px;">
                The <strong>Visualization Frequency</strong> controls how often the visualizations refresh during training. You can always click <strong>Pause Training</strong> to pause the iterations.<br>
                Users may click <strong>[Clear&Restart]</strong> to reset the demo & re-initialize the model. Please wait until process finish informed in the log.
            </p>
        </div>

        <!-- Toggle button for showing/hiding details -->
        <p style="font-size: 14px; cursor: pointer; color: blue;" id="toggleInstructions">Click here to view detailed instructions ▼</p>
    </div>
</div>

<!-- JavaScript for the collapsible behavior -->
<script>
    const toggleInstructions = document.getElementById('toggleInstructions');
    const instructionsContent = document.getElementById('instructionsContent');

    toggleInstructions.addEventListener('click', function () {
        if (instructionsContent.style.display === 'none' || instructionsContent.style.display === '') {
            instructionsContent.style.display = 'block';
            toggleInstructions.textContent = 'Click here to hide detailed instructions ▲';
        } else {
            instructionsContent.style.display = 'none';
            toggleInstructions.textContent = 'Click here to view detailed instructions ▼';
        }
    });
</script>
      <br>
<div style="width: 900px; margin: 0 auto;">
      <div class="input-group">
          <a>Pre-Training Iterations: </a><input type="number" id="kWarmup" value="150" placeholder="#Warmup" style="width: 60px;">
          <button id="runWarmupButton" style="margin-right: 60px;">Pre-Training</button>
          <a>Joint-Training Iterations: </a><input type="number" id="kIteration" value="90" placeholder="#Iteration" style="width: 60px;">
          <button id="runIterationButton">Joint Training</button>
    </div>
    <div class="input-group">
          <a>Visualization Frequency: </a><input type="number" id="displayFreq" value="30" placeholder="#displayFreq" style="width: 60px;">
          <button id="initializeButton">Clear&Restart</button>
           <button id="stopButton">Pause Training</button>
      </div>
    <div class="input-group">
      <input type="text" id="idInput" placeholder="ID" style="width: 60px;">
      <input type="text" id="beliefInput" placeholder="Political Subject">
      <input type="text" id="stanceInput" placeholder="Belief">
      <button id="addSemiSupervisionButton">Add Manual Annotations</button><br>
    </div>
      <div class="input-group">
        <a>Percentage to Annotate: </a><input type="number" id="gptPercentage" value="10" placeholder="" style="width: 60px;"><a>%</a>
      <button id="addRandomSemiSupervisionButton">Add GPT Annotations</button>
    </div>
</div>
    <div id="logTextBox" style="margin: 0 auto;">[Model Log]</div>

    <h3 style="text-align: left; margin-bottom: 5px;">Subject Embedding (Each plot show 3 out of 7 dimensions of the Subject Embedding)</h3>

<div style="display: flex; flex-wrap: wrap; justify-content: space-between;">
    <figure style="display: flex; flex-direction: column; align-items: center; margin-right: 0; width: 300px;">
        <canvas id="CanvasB1"></canvas>
        <figcaption id="captionB1" style="text-align: center; word-wrap: break-word; max-width: 100%; margin-top: 10px;">Loading...</figcaption>
    </figure>

    <figure style="display: flex; flex-direction: column; align-items: center; margin-right: 0; width: 300px;">
        <canvas id="CanvasB2"></canvas>
        <figcaption id="captionB2" style="text-align: center; word-wrap: break-word; max-width: 100%; margin-top: 10px;">Loading...</figcaption>
    </figure>

    <figure style="display: flex; flex-direction: column; align-items: center; margin-right: 0; width: 300px;">
        <canvas id="CanvasB3"></canvas>
        <figcaption id="captionB3" style="text-align: center; word-wrap: break-word; max-width: 100%; margin-top: 10px;">Loading...</figcaption>
    </figure>

    <figure style="display: flex; flex-direction: column; align-items: center; margin-right: 0; width: 300px;">
        <canvas id="CanvasB4"></canvas>
        <figcaption id="captionB4" style="text-align: center; word-wrap: break-word; max-width: 100%; margin-top: 10px;">Loading...</figcaption>
    </figure>
</div>

    <h3 style="text-align: left; margin-bottom: 5px;">Belief Embeddings (One plot per subject)</h3>

    <div style="display: flex; flex-wrap: wrap; justify-content: space-between;">
    <figure style="display: flex; flex-direction: column; align-items: center; margin-right: 0; width: 300px;">
        <canvas id="CanvasP1"></canvas>
        <figcaption id="captionP1" style="text-align: center; word-wrap: break-word; max-width: 100%; margin-top: 10px;">Loading...</figcaption>
    </figure>
    <figure style="display: flex; flex-direction: column; align-items: center; margin-right: 0; width: 300px;">
        <canvas id="CanvasP2"></canvas>
        <figcaption id="captionP2" style="text-align: center; word-wrap: break-word; max-width: 100%; margin-top: 10px;">Loading...</figcaption>
    </figure>
    <figure style="display: flex; flex-direction: column; align-items: center; margin-right: 0; width: 300px;">
        <canvas id="CanvasP3"></canvas>
        <figcaption id="captionP3" style="text-align: center; word-wrap: break-word; max-width: 100%; margin-top: 10px;">Loading...</figcaption>
    </figure>
    <figure style="display: flex; flex-direction: column; align-items: center; margin-right: 0; width: 300px;">
        <canvas id="CanvasP4"></canvas>
        <figcaption id="captionP4" style="text-align: center; word-wrap: break-word; max-width: 100%; margin-top: 10px;">Loading...</figcaption>
    </figure>
    </div>
    <br>
    <div style="display: flex; flex-wrap: wrap; justify-content: space-between;">
    <figure style="display: flex; flex-direction: column; align-items: center; margin-right: 0; width: 300px;">
        <canvas id="CanvasP5"></canvas>
        <figcaption id="captionP5" style="text-align: center; word-wrap: break-word; max-width: 100%; margin-top: 10px;">Loading...</figcaption>
    </figure>

    <figure style="display: flex; flex-direction: column; align-items: center; margin-right: 0; width: 300px;">
        <canvas id="CanvasP6"></canvas>
        <figcaption id="captionP6" style="text-align: center; word-wrap: break-word; max-width: 100%; margin-top: 10px;">Loading...</figcaption>
    </figure>

    <figure style="display: flex; flex-direction: column; align-items: center; margin-right: 0; width: 300px;">
      <canvas id="CanvasP7"></canvas>
      <figcaption id="captionP7" style="text-align: center; word-wrap: break-word; max-width: 100%; margin-top: 10px;">Loading...</figcaption>
    </figure>
<!--    <figure style="display: flex; flex-direction: column; align-items: center; margin-right: 0; width: 300px;">-->
<!--      <canvas id="CanvasP8"></canvas>-->
<!--      <figcaption id="captionP8" style="text-align: center; word-wrap: break-word; max-width: 100%; margin-top: 10px;">Loading...</figcaption>-->
<!--    </figure>-->
    </div>

      <h3 style="text-align: left; margin-bottom: 5px;">Table Summary & Tweets</h3>
      <div>
<br>
          <br>
<table id="editableTable1">
        <!-- First row -->
        <tr>
            <th rowspan="1">Political Issues</th>
            <td colspan="2">1</td>
            <td colspan="2">2</td>
            <td colspan="2">3</td>
            <td colspan="2">4</td>
        </tr>

        <!-- Second row -->
        <tr>
            <td>Stances</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>

        <!-- Third row -->
        <tr>
            <td>Top Tweets</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
    </table>
<br>
          <br>

  <table id="editableTable2">
        <!-- First row -->
        <tr>
            <th rowspan="1">Political Issues</th>
            <td colspan="2">5</td>
            <td colspan="2">6</td>
            <td colspan="2">7</td>
        </tr>

        <!-- Second row -->
        <tr>
            <td>Stances</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>

        <!-- Third row -->
        <tr>
            <td>Top Tweets</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
    </table>
    <br>
          <br>
      </div>

    <div id="tooltip" style="max-width: 500px;"></div>
    <br><br><br><br><br><br><br><br><br><br>
    <p id="session_id" data-unique-id="{{ unique_id }}">Session ID: {{ unique_id }}</p>
  </div>

  <script>
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let tooltip = document.getElementById('tooltip');
    let idInput = document.getElementById('idInput');
    let highlightedPoints = new Set();  // Store highlighted point IDs

    let is_onload = true;
    let isRunning = false; // Flag to indicate if the function is running
    let stopNow = false;

    document.getElementById('initializeButton').addEventListener('click', async () => {
        is_onload = false;
        const logTextBox = document.getElementById('logTextBox');  // Assuming logTextBox is defined earlier
        if (isRunning) {
            logTextBox.textContent += "\n" + "Operation already in progress. Please wait.";
            logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom
            return; // Exit if the function is already running
        }
        isRunning = true; // Set the flag to true indicating the process has started

        var uniqueId = document.getElementById('session_id').getAttribute('data-unique-id');
        for (let i = 1; i <= 4; i++) {
            clearCanvas(`CanvasB${i}`);
            document.getElementById(`captionB${i}`).textContent = "";
        }
        for (let i = 1; i <= 7; i++) {
            clearCanvas(`CanvasP${i}`);
            document.getElementById(`captionP${i}`).textContent = "";
        }

        highlightedPoints.clear();

        let handles = ['/initialize/', "/dataset_build/", "/model_build/"];

        for (let i = 0; i < handles.length; i++) {
            try {
                logTextBox.textContent += "\n" + "Executing " + handles[i] + "\nPlease wait...";
                logTextBox.scrollTop = logTextBox.scrollHeight;

                const response = await fetch(handles[i] + uniqueId, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({sessionId: uniqueId})
                });
                const data = await response.json();

                logTextBox.textContent += "\n" + data.returnString;
                logTextBox.scrollTop = logTextBox.scrollHeight;
            } catch (error) {
                console.error('Error:', error);
            }
        }

        logTextBox.textContent += "\n" + "Initialization Done. You may start pre-training for issue embeddings.";
                logTextBox.scrollTop = logTextBox.scrollHeight;

        isRunning = false; // Reset the flag after the process is complete
    });

    document.getElementById('runWarmupButton').addEventListener('click', async () => {
        const logTextBox = document.getElementById('logTextBox');  // Assuming logTextBox is defined earlier
        if (is_onload) {
            for (let i = 1; i <= 4; i++) {
                clearCanvas(`CanvasB${i}`);
                document.getElementById(`captionB${i}`).textContent = "";
            }
            for (let i = 1; i <= 7; i++) {
                clearCanvas(`CanvasP${i}`);
                document.getElementById(`captionP${i}`).textContent = "";
            }
            highlightedPoints.clear();
            logTextBox.textContent += "\n" + "Model being initialized. Please wait...";
            logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom
        }
        is_onload=false;

        if (isRunning) {
            logTextBox.textContent += "\n" + "Operation already in progress. Please wait.";
            logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom
            return; // Exit if the function is already running
        }
        isRunning = true; // Set the flag to true indicating the process has started

        var uniqueId = document.getElementById('session_id').getAttribute('data-unique-id');
        const iterations = parseInt(document.getElementById('kWarmup').value, 10);  // Get the number of iterations from the input
        const freq = parseInt(document.getElementById('displayFreq').value, 10);  // Get the number of iterations from the input

        for (let i = 0; i < iterations; i++) {
            if (stopNow) {
                stopNow = false;
                isRunning = false;
                const logTextBox = document.getElementById('logTextBox');  // Assuming logTextBox is defined earlier
                logTextBox.textContent += "\n" + "Execution Stopped. You may continue running by clicking button.";
                logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom
                break;
            }
            try {
                logTextBox.textContent += "\n" + "Executing /run_pretraining/";
                logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom
                const do_visualize = (i % freq === 0 || i === iterations - 1) ? "true" : "false";
                if (do_visualize === "true") {
                    logTextBox.textContent += "\n" + "Visualization in progress...";  // Assuming response includes 'returnString'
                    logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom
                }
                const response = await fetch("/run_warmup/" + uniqueId, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({sessionId: uniqueId, do_visualize: do_visualize})
                });
                const data = await response.json();  // Wait for the JSON response

                // Concatenate the return value to the logTextBox
                logTextBox.textContent += "\n" + data.returnString;  // Assuming response includes 'returnString'
                logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom
                if (do_visualize === "true") {
                    await refreshVisualizations();  // Ensure that refreshVisualizations is awaited
                }
            } catch (error) {
                console.error('Error:', error);
                // Optionally handle errors, e.g., break the loop or display an error message
            }
        }

        logTextBox.textContent += "\n" + "Run pre-training Done";
        logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom

        isRunning = false;
    });

    document.getElementById('stopButton').addEventListener('click', async () => {
        if (!isRunning){
            return
        }
        const logTextBox = document.getElementById('logTextBox');  // Assuming logTextBox is defined earlier
        logTextBox.textContent += "\n" + "Stopping...";
        logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom
        stopNow = true;
    });

    document.getElementById('runIterationButton').addEventListener('click', async () => {
        const logTextBox = document.getElementById('logTextBox');  // Assuming logTextBox is defined earlier
        if (is_onload) {
            for (let i = 1; i <= 4; i++) {
                clearCanvas(`CanvasB${i}`);
                document.getElementById(`captionB${i}`).textContent = "";
            }
            for (let i = 1; i <= 7; i++) {
                clearCanvas(`CanvasP${i}`);
                document.getElementById(`captionP${i}`).textContent = "";
            }
            highlightedPoints.clear();
            logTextBox.textContent += "\n" + "Model being initialized. Please wait...";
            logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom
        }
        is_onload = false;
        if (isRunning) {
            logTextBox.textContent += "\n" + "Operation already in progress. Please wait.";
            logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom
            return; // Exit if the function is already running
        }
        isRunning = true; // Set the flag to true indicating the process has started

        var uniqueId = document.getElementById('session_id').getAttribute('data-unique-id');
        const iterations = parseInt(document.getElementById('kIteration').value, 10);  // Get the number of iterations from the input
        const freq = parseInt(document.getElementById('displayFreq').value, 10);  // Get the number of iterations from the input

        for (let i = 0; i < iterations; i++) {
            if (stopNow) {
                stopNow = false;
                isRunning = false;
                const logTextBox = document.getElementById('logTextBox');  // Assuming logTextBox is defined earlier
                logTextBox.textContent += "\n" + "Execution Stopped. You may continue running or add semi-supervision by clicking button.";
                logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom
                break;
            }
            try {
                logTextBox.textContent += "\n" + "Executing /run_iteration/";
                logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom
                const do_visualize = (i % freq === 0 || i === iterations - 1) ? "true" : "false";
                if (do_visualize === "true") {
                    logTextBox.textContent += "\n" + "Visualization in progress...";  // Assuming response includes 'returnString'
                    logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom
                }
                const response = await fetch("/run_iteration/" + uniqueId, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({sessionId: uniqueId, do_visualize: do_visualize})
                });
                const data = await response.json();  // Wait for the JSON response

                // Concatenate the return value to the logTextBox
                logTextBox.textContent += "\n" + data.returnString;  // Assuming response includes 'returnString'
                logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom
                if (do_visualize === "true") {
                    await refreshVisualizations();  // Ensure that refreshVisualizations is awaited
                }
            } catch (error) {
                console.error('Error:', error);
                // Optionally handle errors, e.g., break the loop or display an error message
            }
        }

        logTextBox.textContent += "\n" + "Run Iterations Done";
        logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom

        isRunning = false;
    });

    document.getElementById('addRandomSemiSupervisionButton').addEventListener('click', async () => {
        const logTextBox = document.getElementById('logTextBox');  // Assuming logTextBox is defined earlier
        if (isRunning) {
            logTextBox.textContent += "\n" + "Operation already in progress. Please wait.";
            logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom
            return; // Exit if the function is already running
        }
        isRunning = true; // Set the flag to true indicating the process has started

        var uniqueId = document.getElementById('session_id').getAttribute('data-unique-id');
        const percentage = parseInt(document.getElementById('gptPercentage').value, 10);  // Get the percentage from the input
        try {
            logTextBox.textContent += "\n" + "Executing /add_gpt_semi/" + uniqueId;
            logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom
            const response = await fetch("/add_gpt_semi/" + uniqueId, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({sessionId: uniqueId, percentage: percentage})  // Include the percentage in the request body
            });
            const data = await response.json();  // Wait for the JSON response
            // Concatenate the return value to the logTextBox
            logTextBox.textContent += "\n" + data.returnString;  // Assuming response includes 'returnString'
            logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom
            // refreshVisualizations();  // Assuming this function is defined to update the UI
        } catch (error) {
            alert(error);
            console.error('Error:', error);
            // Optionally handle errors, e.g., break the loop or display an error message
        }

        isRunning = false;
    });

    document.getElementById('addSemiSupervisionButton').addEventListener('click', async () => {
        const logTextBox = document.getElementById('logTextBox');  // Assuming logTextBox is defined earlier
        if (isRunning) {
            logTextBox.textContent += "\n" + "Operation already in progress. Please wait.";
            logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom
            return; // Exit if the function is already running
        }
        isRunning = true; // Set the flag to true indicating the process has started

        var uniqueId = document.getElementById('session_id').getAttribute('data-unique-id');
        const id = idInput.value;
        const belief = document.getElementById('beliefInput').value;
        const stance = document.getElementById('stanceInput').value;

        try {
            logTextBox.textContent += "\n" + "Executing /add_semi_supervision/" + uniqueId;
            logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom
            const response = await fetch("/add_semi_supervision/" + uniqueId, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({sessionId: uniqueId, id: id, belief: belief, stance: stance})  // Include the percentage in the request body
            });
            const data = await response.json();  // Wait for the JSON response
            // Concatenate the return value to the logTextBox
            logTextBox.textContent += "\n" + data.returnString;  // Assuming response includes 'returnString'
            logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom
            // refreshVisualizations();  // Assuming this function is defined to update the UI
        } catch (error) {
            console.error('Error:', error);
            // Optionally handle errors, e.g., break the loop or display an error message
        }

        isRunning = false;
    });

function create3DVisualization(canvasId, data, label_data) {
  clearCanvas(canvasId);
  const canvas = document.getElementById(canvasId);
  const renderer = new THREE.WebGLRenderer({ canvas });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(canvas.clientWidth, canvas.clientHeight);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xFFFFFF);

  const camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
  camera.position.set(5, 5, 5);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.1;
  controls.update();

  const gridSize = 30;
  const divisions = 30;

  const gridHelper = new THREE.GridHelper(gridSize, divisions);
  gridHelper.position.set(gridSize / 2, 0, gridSize / 2);
  scene.add(gridHelper);

  function createArrowHelper(dir, origin, length, color, arrowHeadLength, arrowHeadWidth) {
    const arrowHelper = new THREE.ArrowHelper(dir, origin, length, color, arrowHeadLength, arrowHeadWidth);
    scene.add(arrowHelper);
  }

  const length = 10;
  const arrowHeadLength = 0.5;
  const arrowHeadWidth = 0.3;
  createArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), length, 0x03016e, arrowHeadLength, arrowHeadWidth);
  createArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), length, 0x6e1101, arrowHeadLength, arrowHeadWidth);
  createArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), length, 0x016e1c, arrowHeadLength, arrowHeadWidth);

  let xLabel, yLabel, zLabel;
  const loader = new THREE.FontLoader();
  loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
    xLabel = createAxisLabel(font, label_data[0], 4, 0, 0);
    yLabel = createAxisLabel(font, label_data[1], 0, 4, 0);
    zLabel = createAxisLabel(font, label_data[2], 0, 0, 4);
    scene.add(xLabel, yLabel, zLabel);
  });

  function createAxisLabel(font, text, x, y, z) {
    const geometry = new THREE.TextGeometry(text, {
      font: font,
      size: 0.3,
      height: 0.03,
    });
    const material = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(x, y, z);
    return mesh;
  }

  const meshArray = [];

  data.forEach(point => {
    let point_size = 0.12;

    const coords = [point.x, point.y, point.z];
    const maxIndex = coords.indexOf(Math.max(...coords));

    const xColor = new THREE.Color(0x1281ff);
    const yColor = new THREE.Color(0xff3d12);
    const zColor = new THREE.Color(0x44ba00);
    let color;
    if (maxIndex === 0) {
      color = xColor;
    } else if (maxIndex === 1) {
      color = yColor;
    } else {
      color = zColor;
    }

    if (highlightedPoints.has(point.id)) {
      color = new THREE.Color(0xc142fc);
      point_size = point_size * 2;
    }

    const geometry = new THREE.TetrahedronGeometry(point_size);
    const material = new THREE.MeshBasicMaterial({ color: color });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(point.x, point.y, point.z);
    mesh.userData = { id: point.id, text: point.text, type: "tweet"};

    scene.add(mesh);
    meshArray.push(mesh);
  });

  canvas.addEventListener('mousemove', (event) => onMouseMove(event, canvas, camera, meshArray));
  canvas.addEventListener('click', (event) => onMeshClick(event, canvas, camera, meshArray));

  function animate() {
    requestAnimationFrame(animate);

    // Make axis labels always face the camera (billboarding)
    if (xLabel && yLabel && zLabel) {
      xLabel.lookAt(camera.position);
      yLabel.lookAt(camera.position);
      zLabel.lookAt(camera.position);
    }

    controls.update();
    renderer.render(scene, camera);
  }
  animate();
}

// function clearCanvas(canvasId) {
//   const canvas = document.getElementById(canvasId);
//   const newCanvas = canvas.cloneNode(false);
//   canvas.parentNode.replaceChild(newCanvas, canvas);
// }

// function clearCanvas(canvasId) {
//     const canvas = document.getElementById(canvasId);
//
//     // Check if the canvas has a renderer attached
//     if (canvas.renderer) {
//         // Properly dispose of all WebGL resources to free up memory
//         canvas.renderer.dispose();
//         if (canvas.renderer.domElement) {
//             // Manually release the WebGL context if possible
//             const gl = canvas.renderer.domElement.getContext('webgl') || canvas.renderer.domElement.getContext('experimental-webgl');
//             if (gl) {
//                 const ext = gl.getExtension('WEBGL_lose_context');
//                 if (ext) {
//                     ext.loseContext();
//                 }
//             }
//         }
//         // Clear the reference to the renderer
//         canvas.renderer = null;
//     }
//
//     // Replace the old canvas to completely reset its state
//     const newCanvas = canvas.cloneNode(false);
//     canvas.parentNode.replaceChild(newCanvas, canvas);
// }

    function clearCanvas(canvasId) {
        const canvas = document.getElementById(canvasId);

        // Check if the canvas has a renderer attached
        if (canvas.renderer) {
            // Dispose of the renderer and all WebGL resources
            canvas.renderer.dispose();

            // Dispose of any objects in the scene, including geometries, materials, and textures
            if (canvas.scene) {
                canvas.scene.traverse(function (object) {
                    if (object.geometry) {
                        object.geometry.dispose();
                    }
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach((material) => {
                                if (material.map) material.map.dispose();
                                material.dispose();
                            });
                        } else {
                            if (object.material.map) object.material.map.dispose();
                            object.material.dispose();
                        }
                    }
                });
            }

            // Release the WebGL context if possible
            if (canvas.renderer.domElement) {
                const gl = canvas.renderer.domElement.getContext('webgl') || canvas.renderer.domElement.getContext('experimental-webgl');
                if (gl) {
                    const ext = gl.getExtension('WEBGL_lose_context');
                    if (ext) {
                        ext.loseContext();
                    }
                }
            }

            // Clear references to the renderer and scene
            canvas.renderer = null;
            canvas.scene = null;
        }

        // Replace the old canvas to completely reset its state
        const newCanvas = canvas.cloneNode(false);
        canvas.parentNode.replaceChild(newCanvas, canvas);
    }

function createCombinedVisualization(canvasId, tweetsData, usersData, label_data) {
    clearCanvas(canvasId);
    const canvas = document.getElementById(canvasId);
    const renderer = new THREE.WebGLRenderer({ canvas });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xFFFFFF);

    const camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
    camera.position.set(5, 5, 5);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;
    controls.update();

    const gridSize = 30;
    const divisions = 30;

    const gridHelper = new THREE.GridHelper(gridSize, divisions);
    gridHelper.position.set(gridSize / 2, 0, gridSize / 2);
    scene.add(gridHelper);

    function createArrowHelper(dir, origin, length, color, arrowHeadLength, arrowHeadWidth) {
        const arrowHelper = new THREE.ArrowHelper(dir, origin, length, color, arrowHeadLength, arrowHeadWidth);
        scene.add(arrowHelper);
    }

    const length = 10;
    const arrowHeadLength = 0.5;
    const arrowHeadWidth = 0.3;
    createArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), length, 0x03016e, arrowHeadLength, arrowHeadWidth);
    createArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), length, 0x6e1101, arrowHeadLength, arrowHeadWidth);
    createArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), length, 0x016e1c, arrowHeadLength, arrowHeadWidth);

    const loader = new THREE.FontLoader();
    let xLabel, yLabel, zLabel;

    loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
        xLabel = createAxisLabel(font, label_data[0], 4, 0, 0);
        yLabel = createAxisLabel(font, label_data[1], 0, 4, 0);
        zLabel = createAxisLabel(font, label_data[2], 0, 0, 4);
        scene.add(xLabel, yLabel, zLabel);
    });

    function createAxisLabel(font, text, x, y, z) {
        const geometry = new THREE.TextGeometry(text, {
            font: font,
            size: 0.3,
            height: 0.03,
        });
        const material = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(x, y, z);
        return mesh;
    }

    const meshArray = [];

    tweetsData.forEach(point => {
        let point_size = 0.12;
        const coords = [point.x, point.y, point.z];
        const maxIndex = coords.indexOf(Math.max(...coords));

        const xColor = new THREE.Color(0x1281ff);
        const yColor = new THREE.Color(0xff3d12);
        const zColor = new THREE.Color(0x44ba00);
        let color;
        if (maxIndex === 0) {
            color = xColor;
        } else if (maxIndex === 1) {
            color = yColor;
        } else {
            color = zColor;
        }

        if (highlightedPoints.has(point.id)) {
            color = new THREE.Color(0xc142fc);
            point_size = point_size * 2;
        }

        const geometry = new THREE.TetrahedronGeometry(point_size);
        const material = new THREE.MeshBasicMaterial({ color: color });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(point.x, point.y, point.z);
        mesh.userData = { id: point.id, text: point.text, type: "tweet"};

        scene.add(mesh);
        meshArray.push(mesh);
    });

    usersData.forEach(point => {
        const geometry = new THREE.SphereGeometry(0.06, 8, 8);
        const coords = [point.x, point.y, point.z];
        const maxIndex = coords.indexOf(Math.max(...coords));

        const xColor = new THREE.Color(0x0049b0);
        const yColor = new THREE.Color(0xb00000);
        const zColor = new THREE.Color(0x00b00c);
        let color;
        if (maxIndex === 0) {
            color = xColor;
        } else if (maxIndex === 1) {
            color = yColor;
        } else {
            color = zColor;
        }

        // if (highlightedPoints.has(point.id)) {
        //     color = new THREE.Color(0x000000);
        // }

        const material = new THREE.MeshBasicMaterial({ color: color });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(point.x, point.y, point.z);
        mesh.userData = { id: point.id, text: point.text, type: "user"};

        scene.add(mesh);
        meshArray.push(mesh);
    });

    canvas.addEventListener('mousemove', (event) => onMouseMove(event, canvas, camera, meshArray));
    canvas.addEventListener('click', (event) => onMeshClick(event, canvas, camera, meshArray));

    function animate() {
        requestAnimationFrame(animate);

        // Make axis labels always face the camera (billboarding)
        if (xLabel && yLabel && zLabel) {
            xLabel.lookAt(camera.position);
            yLabel.lookAt(camera.position);
            zLabel.lookAt(camera.position);
        }

        controls.update();
        renderer.render(scene, camera);
    }
    animate();
}

    function onMouseMove(event, canvas, camera, meshArray) {
      const canvasBounds = canvas.getBoundingClientRect();

      // Calculate the mouse position correctly for each canvas
      mouse.x = ((event.clientX - canvasBounds.left) / canvasBounds.width) * 2 - 1;
      mouse.y = -((event.clientY - canvasBounds.top) / canvasBounds.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);

      // Check intersection with all meshes
      const intersects = raycaster.intersectObjects(meshArray);

      if (intersects.length > 0) {
        const intersect = intersects[0];
        const text = intersect.object.userData.text;  // Access the corresponding text

        // Display tooltip with the text, adjust position dynamically for each canvas
        tooltip.style.display = 'block';
        tooltip.style.left = `${event.pageX + 10}px`;
        tooltip.style.top = `${event.pageY + 10}px`;
        tooltip.textContent = text;
      } else {
        tooltip.style.display = 'none';
      }
    }

    function onMeshClick(event, canvas, camera, meshArray) {
      const canvasBounds = canvas.getBoundingClientRect();

      mouse.x = ((event.clientX - canvasBounds.left) / canvasBounds.width) * 2 - 1;
      mouse.y = -((event.clientY - canvasBounds.top) / canvasBounds.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);

      const intersects = raycaster.intersectObjects(meshArray);

      if (intersects.length > 0) {
        const intersect = intersects[0];
        const id = intersect.object.userData.id;  // Access the corresponding ID
        const type = intersect.object.userData.type;
        if (type === "user"){
            const logTextBox = document.getElementById('logTextBox');  // Assuming logTextBox is defined earlier
            logTextBox.textContent += "\n" + "You can only select tweet node (triangles) for semi-supervision. Please select again!";
            logTextBox.scrollTop = logTextBox.scrollHeight;  // Auto-scroll to bottom
            return;
        }
        idInput.value = id;  // Copy the ID to the input field

        // Highlight the clicked point and store its ID
        highlightedPoints.add(id);
      }
    }

//     function refreshVisualizations(use_example = false) {
//     var uniqueId = document.getElementById('session_id').getAttribute('data-unique-id');
//     // Add use_example and uniqueId as query parameters
//     fetch(`/get_visualization_data/${uniqueId}?use_example=${use_example}`)
//         .then(response => response.json())
//         .then(data => {
//             data.belief_caption_data.forEach((caption, index) => {
//                 create3DVisualization(
//                     `CanvasB${index+1}`, data.belief_data[index], data.belief_label_data[index]);
//                 document.getElementById(`captionB${index+1}`).textContent = caption;
//             });
//             data.polar_caption_data.forEach((caption, index) => {
//                 createCombinedVisualization(
//                     `CanvasP${index+1}`, data.polar_data[index].tweet_data, data.polar_data[index].user_data,
//                     data.polar_label_data[index]);
//                 document.getElementById(`captionP${index+1}`).textContent = caption;
//             });
//         });
// }

    function updateTable(data) {
        const table = document.getElementById('editableTable1');
        // Update the first row (belief_label_data) using a for loop
        let firstRowCells = table.rows[0].cells;
        for (let i = 0; i < 4; i++) {
            if (firstRowCells[i + 1]) {  // Skip first cell, start from second column
                firstRowCells[i + 1].innerText = data.belief_axis_meaning[i];
            }
        }
        // Update the second row (polar_label_data) using a for loop
        let secondRowCells = table.rows[1].cells;
        for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 2; j ++){
                if (secondRowCells[i * 2 + j + 1]) {  // Skip first cell, start from second column
                    secondRowCells[i * 2 + j + 1].innerText = data.polar_axis_meaning[i][j];
                }
            }
        }
        let thirdRowCells = table.rows[2].cells;
        for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 2; j ++){
                if (thirdRowCells[i * 2 + j + 1]) {  // Skip first cell, start from second column
                    thirdRowCells[i * 2 + j + 1].innerText = data.top_tweets[i][j];
                }
            }
        }

        const table2 = document.getElementById('editableTable2');
        // Update the first row (belief_label_data) using a for loop
        let firstRowCells2 = table2.rows[0].cells;
        for (let i = 0; i < 4; i++) {
            if (firstRowCells2[i + 1]) {  // Skip first cell, start from second column
                firstRowCells2[i + 1].innerText = data.belief_axis_meaning[i + 4];
            }
        }
        // Update the second row (polar_label_data) using a for loop
        let secondRowCells2 = table2.rows[1].cells;
        for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 2; j ++){
                if (secondRowCells2[i * 2 + j + 1]) {  // Skip first cell, start from second column
                    secondRowCells2[i * 2 + j + 1].innerText = data.polar_axis_meaning[i + 4][j];
                }
            }
        }
        let thirdRowCells2 = table2.rows[2].cells;
        for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 2; j ++){
                if (thirdRowCells2[i * 2 + j + 1]) {  // Skip first cell, start from second column
                    thirdRowCells2[i * 2 + j + 1].innerText = data.top_tweets[i + 4][j];
                }
            }
        }

    }

    function refreshVisualizations(use_example = false) {
    var uniqueId = document.getElementById('session_id').getAttribute('data-unique-id');

    // Return a promise
    return new Promise((resolve, reject) => {
        // Fetch the data with uniqueId and use_example as query parameters
        fetch(`/get_visualization_data/${uniqueId}?use_example=${use_example}`)
            .then(response => response.json())
            .then(data => {
                // Process the data and update the visualizations
                data.belief_caption_data.forEach((caption, index) => {
                    create3DVisualization(
                        `CanvasB${index+1}`, data.belief_data[index], data.belief_label_data[index]
                    );
                    document.getElementById(`captionB${index+1}`).innerHTML = caption;
                });

                data.polar_caption_data.forEach((caption, index) => {
                    createCombinedVisualization(
                        `CanvasP${index+1}`, data.polar_data[index].tweet_data, data.polar_data[index].user_data,
                        data.polar_label_data[index]
                    );
                    document.getElementById(`captionP${index+1}`).innerHTML = caption;
                });

                updateTable(data);

                // Resolve the promise once everything is done
                resolve();
            })
            .catch(error => {
                // If there's an error, reject the promise
                console.error('Error fetching visualization data:', error);
                reject(error);
            });
    });
}


    // Automatically load the visualizations when the page is opened
    window.onload = () => {
      refreshVisualizations(true);
    };

    // Send a request to delete the directory when the page is about to be closed or refreshed
    window.onbeforeunload = function() {
        // Get the unique ID from the template
        var uniqueId = document.getElementById('session_id').getAttribute('data-unique-id');

        // Make a POST request to the server to delete the directory
        fetch('/delete_directory/' + uniqueId, {
            method: 'POST'
        }).then(response => response.json())
          .then(data => console.log(data))
          .catch(error => console.error('Error:', error));

        return null;  // Return null to indicate that no custom message is shown when closing the window
    };

  </script>
</body>
</html>
